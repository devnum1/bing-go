package ewo_dgtrd

import (
	"context"

	"github.com/sirupsen/logrus"

	"github.com/c9s/bbgo/pkg/bbgo"
	"github.com/c9s/bbgo/pkg/fixedpoint"
	"github.com/c9s/bbgo/pkg/types"
)

const ID = "ewo_dgtrd"

var log = logrus.WithField("strategy", ID)

func init() {
	bbgo.RegisterStrategy(ID, &Strategy{})
}

type Strategy struct {
        Symbol string `json:"symbol"`
	Interval types.Interval `json:"interval"`
	Threshold float64 `json:"threshold"` // strength threshold
	UseEma bool `json:"useEma"` // use exponential ma or simple ma
	SignalWindow int `json:"sigWin"` // signal window 
}

func (s *Strategy) ID() string {
        return ID
}

func (s *Strategy) Subscribe(session *bbgo.ExchangeSession) {
        log.Infof("subscribe %s", s.Symbol)
        session.Subscribe(types.KLineChannel, s.Symbol, types.SubscribeOptions{Interval: s.Interval.String()})
}

type EwoSignal interface {
	types.Series
	Update(value float64)
}

func (s *Strategy) Run(ctx context.Context, orderExecutor bbgo.OrderExecutor, session *bbgo.ExchangeSession) error {
	store, ok := session.MarketDataStore(s.Symbol)
	if !ok {
		log.Errorf("cannot find symbol %s", s.Symbol)
		return
	}
	klineWindow, ok := store.KLinesOfInterval(s.Interval)
	if !ok {
		log.Errorf("cannot find kline window of %v", s.Interval)
		return
	}
	indicatorSet, ok := session.StandardIndicatorSet(s.Symbol)
	if !ok {
		log.Errorf("cannot get indicatorSet of %s", s.Symbol)
		return
	}
	var ma5, ma34 Series
	if s.UseEma {
		ma5 = indicatorSet.EWMA(types.IntervalWindow{s.Interval, 5})
		ma34 = indicatorSet.EWMA(types.IntervalWindow{s.Interval, 34})
	} else {
		ma5 = indicatorSet.SMA(types.IntervalWindow{s.Interval, 5})
		ma34 = indicatorSet.SMA(types.IntervalWindow{s.Interval, 34})
	}
	var ewoSignal EwoSignal
	if s.UseEma {
		ewoSignal := &indicator.EWMA{types.IntervalWindow{s.Interval, s.SignalWindow}}
	} else {
		ewoSignal := &indicator.SMA{types.IntervalWindow{s.Interval, s.SignalWindow}}
	}
	for _, kline := range klineWindow {
		ewoSignal.Update(kline)
	}
	session.MarketDataStream.OnKLineClosed(func(kline types.KLine) {
		var ewo
		if kline.Symbol != s.Symbol {
			return
		}
		ewo = types.Mul(types.Minus(types.Div(ma5, ma34), 1.0), 100.)
		ewoSignal.Update(ewo.Last())

		if s.UseEma {
			ewoSignal = indicator.EWMA(ewo, s.SignalWindow)
		} else {
			ewoSignal = sma(ewo, s.SignalWindow)
		}

		if CrossOver(ewo, ewoSignal).Last() {
			if ewo.Last() < -s.Threshold {
				// strong long
			} else {
				// Long
			}
		} else if CrossUnder(ewo, ewoSignal).Last() {
			if ewo.Last() > s.Threshold {
				// Strong short
			} else {
				// short
			}
		}
}
